// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mace.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mace.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace mace {
class ConstTensorDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<ConstTensor>
     _instance;
} _ConstTensor_default_instance_;
class ArgumentDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<Argument>
     _instance;
} _Argument_default_instance_;
class NodeInputDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<NodeInput>
     _instance;
} _NodeInput_default_instance_;
class OutputShapeDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<OutputShape>
     _instance;
} _OutputShape_default_instance_;
class OperatorDefDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<OperatorDef>
     _instance;
} _OperatorDef_default_instance_;
class MemoryBlockDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<MemoryBlock>
     _instance;
} _MemoryBlock_default_instance_;
class MemoryArenaDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<MemoryArena>
     _instance;
} _MemoryArena_default_instance_;
class InputInfoDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<InputInfo>
     _instance;
} _InputInfo_default_instance_;
class OutputInfoDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<OutputInfo>
     _instance;
} _OutputInfo_default_instance_;
class NetDefDefaultTypeInternal {
public:
 ::google::protobuf::internal::ExplicitlyConstructed<NetDef>
     _instance;
} _NetDef_default_instance_;

namespace protobuf_mace_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] GOOGLE_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
  { NULL, NULL, 0, -1, -1, -1, -1, NULL, false },
};

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _ConstTensor_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_ConstTensor_default_instance_);_Argument_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_Argument_default_instance_);_NodeInput_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_NodeInput_default_instance_);_OutputShape_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_OutputShape_default_instance_);_OperatorDef_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_OperatorDef_default_instance_);_MemoryBlock_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_MemoryBlock_default_instance_);_MemoryArena_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_MemoryArena_default_instance_);_InputInfo_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_InputInfo_default_instance_);_OutputInfo_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_OutputInfo_default_instance_);_NetDef_default_instance_._instance.DefaultConstruct();
  ::google::protobuf::internal::OnShutdownDestroyMessage(
      &_NetDef_default_instance_);_NetDef_default_instance_._instance.get_mutable()->mem_arena_ = const_cast< ::mace::MemoryArena*>(
      ::mace::MemoryArena::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
namespace {
void AddDescriptorsImpl() {
  InitDefaults();
}
} // anonymous namespace

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}

}  // namespace protobuf_mace_2eproto

bool NetMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool DataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConstTensor::kDimsFieldNumber;
const int ConstTensor::kDataTypeFieldNumber;
const int ConstTensor::kFloatDataFieldNumber;
const int ConstTensor::kInt32DataFieldNumber;
const int ConstTensor::kNameFieldNumber;
const int ConstTensor::kOffsetFieldNumber;
const int ConstTensor::kDataSizeFieldNumber;
const int ConstTensor::kNodeIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConstTensor::ConstTensor()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.ConstTensor)
}
ConstTensor::ConstTensor(const ConstTensor& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      dims_(from.dims_),
      float_data_(from.float_data_),
      int32_data_(from.int32_data_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(data_type_));
  // @@protoc_insertion_point(copy_constructor:mace.ConstTensor)
}

void ConstTensor::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&node_id_) -
      reinterpret_cast<char*>(&offset_)) + sizeof(node_id_));
  data_type_ = 1;
}

ConstTensor::~ConstTensor() {
  // @@protoc_insertion_point(destructor:mace.ConstTensor)
  SharedDtor();
}

void ConstTensor::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ConstTensor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConstTensor& ConstTensor::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

ConstTensor* ConstTensor::New(::google::protobuf::Arena* arena) const {
  ConstTensor* n = new ConstTensor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConstTensor::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.ConstTensor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  float_data_.Clear();
  int32_data_.Clear();
  if (has_name()) {
    GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*name_.UnsafeRawStringPointer())->clear();
  }
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 30u) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&node_id_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(node_id_));
    data_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ConstTensor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.ConstTensor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 dims = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 8u, input, this->mutable_dims())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_dims())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mace.DataType data_type = 2 [default = DT_FLOAT];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mace::DataType_IsValid(value)) {
            set_data_type(static_cast< ::mace::DataType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float float_data = 3 [packed = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_float_data())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(29u /* 29 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 26u, input, this->mutable_float_data())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 int32_data = 4 [packed = true];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_int32_data())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 34u, input, this->mutable_int32_data())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 offset = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_offset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 data_size = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_data_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &data_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 node_id = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 800 & 0xFF */)) {
          set_has_node_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.ConstTensor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.ConstTensor)
  return false;
#undef DO_
}

void ConstTensor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.ConstTensor)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 dims = 1;
  for (int i = 0, n = this->dims_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      1, this->dims(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional .mace.DataType data_type = 2 [default = DT_FLOAT];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->data_type(), output);
  }

  // repeated float float_data = 3 [packed = true];
  if (this->float_data_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(3, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(static_cast< ::google::protobuf::uint32>(
        _float_data_cached_byte_size_));
    ::google::protobuf::internal::WireFormatLite::WriteFloatArray(
      this->float_data().data(), this->float_data_size(), output);
  }

  // repeated int32 int32_data = 4 [packed = true];
  if (this->int32_data_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(4, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(static_cast< ::google::protobuf::uint32>(
        _int32_data_cached_byte_size_));
  }
  for (int i = 0, n = this->int32_data_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->int32_data(i), output);
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->name(), output);
  }

  // optional int64 offset = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->offset(), output);
  }

  // optional int64 data_size = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->data_size(), output);
  }

  // optional uint32 node_id = 100;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(100, this->node_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.ConstTensor)
}

size_t ConstTensor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.ConstTensor)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated int64 dims = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->dims_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->dims_size());
    total_size += data_size;
  }

  // repeated float float_data = 3 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->float_data_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast< ::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _float_data_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated int32 int32_data = 4 [packed = true];
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->int32_data_);
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
            static_cast< ::google::protobuf::int32>(data_size));
    }
    int cached_size = ::google::protobuf::internal::ToCachedSize(data_size);
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _int32_data_cached_byte_size_ = cached_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 31u) {
    // optional string name = 5;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int64 offset = 6;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->offset());
    }

    // optional int64 data_size = 7;
    if (has_data_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->data_size());
    }

    // optional uint32 node_id = 100;
    if (has_node_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

    // optional .mace.DataType data_type = 2 [default = DT_FLOAT];
    if (has_data_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConstTensor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConstTensor*>(&from));
}

void ConstTensor::MergeFrom(const ConstTensor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.ConstTensor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  float_data_.MergeFrom(from.float_data_);
  int32_data_.MergeFrom(from.int32_data_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000004u) {
      data_size_ = from.data_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      node_id_ = from.node_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      data_type_ = from.data_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ConstTensor::CopyFrom(const ConstTensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.ConstTensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConstTensor::IsInitialized() const {
  return true;
}

void ConstTensor::Swap(ConstTensor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConstTensor::InternalSwap(ConstTensor* other) {
  using std::swap;
  dims_.InternalSwap(&other->dims_);
  float_data_.InternalSwap(&other->float_data_);
  int32_data_.InternalSwap(&other->int32_data_);
  name_.Swap(&other->name_);
  swap(offset_, other->offset_);
  swap(data_size_, other->data_size_);
  swap(node_id_, other->node_id_);
  swap(data_type_, other->data_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string ConstTensor::GetTypeName() const {
  return "mace.ConstTensor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConstTensor

// repeated int64 dims = 1;
int ConstTensor::dims_size() const {
  return dims_.size();
}
void ConstTensor::clear_dims() {
  dims_.Clear();
}
::google::protobuf::int64 ConstTensor::dims(int index) const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.dims)
  return dims_.Get(index);
}
void ConstTensor::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.ConstTensor.dims)
}
void ConstTensor::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:mace.ConstTensor.dims)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ConstTensor::dims() const {
  // @@protoc_insertion_point(field_list:mace.ConstTensor.dims)
  return dims_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ConstTensor::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.dims)
  return &dims_;
}

// optional .mace.DataType data_type = 2 [default = DT_FLOAT];
bool ConstTensor::has_data_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ConstTensor::set_has_data_type() {
  _has_bits_[0] |= 0x00000010u;
}
void ConstTensor::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000010u;
}
void ConstTensor::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
::mace::DataType ConstTensor::data_type() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.data_type)
  return static_cast< ::mace::DataType >(data_type_);
}
void ConstTensor::set_data_type(::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:mace.ConstTensor.data_type)
}

// repeated float float_data = 3 [packed = true];
int ConstTensor::float_data_size() const {
  return float_data_.size();
}
void ConstTensor::clear_float_data() {
  float_data_.Clear();
}
float ConstTensor::float_data(int index) const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.float_data)
  return float_data_.Get(index);
}
void ConstTensor::set_float_data(int index, float value) {
  float_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.ConstTensor.float_data)
}
void ConstTensor::add_float_data(float value) {
  float_data_.Add(value);
  // @@protoc_insertion_point(field_add:mace.ConstTensor.float_data)
}
const ::google::protobuf::RepeatedField< float >&
ConstTensor::float_data() const {
  // @@protoc_insertion_point(field_list:mace.ConstTensor.float_data)
  return float_data_;
}
::google::protobuf::RepeatedField< float >*
ConstTensor::mutable_float_data() {
  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.float_data)
  return &float_data_;
}

// repeated int32 int32_data = 4 [packed = true];
int ConstTensor::int32_data_size() const {
  return int32_data_.size();
}
void ConstTensor::clear_int32_data() {
  int32_data_.Clear();
}
::google::protobuf::int32 ConstTensor::int32_data(int index) const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.int32_data)
  return int32_data_.Get(index);
}
void ConstTensor::set_int32_data(int index, ::google::protobuf::int32 value) {
  int32_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.ConstTensor.int32_data)
}
void ConstTensor::add_int32_data(::google::protobuf::int32 value) {
  int32_data_.Add(value);
  // @@protoc_insertion_point(field_add:mace.ConstTensor.int32_data)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConstTensor::int32_data() const {
  // @@protoc_insertion_point(field_list:mace.ConstTensor.int32_data)
  return int32_data_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConstTensor::mutable_int32_data() {
  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.int32_data)
  return &int32_data_;
}

// optional string name = 5;
bool ConstTensor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConstTensor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ConstTensor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConstTensor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& ConstTensor::name() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.name)
  return name_.GetNoArena();
}
void ConstTensor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.ConstTensor.name)
}
#if LANG_CXX11
void ConstTensor::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.ConstTensor.name)
}
#endif
void ConstTensor::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.ConstTensor.name)
}
void ConstTensor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.ConstTensor.name)
}
::std::string* ConstTensor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.ConstTensor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ConstTensor::release_name() {
  // @@protoc_insertion_point(field_release:mace.ConstTensor.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ConstTensor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.ConstTensor.name)
}

// optional int64 offset = 6;
bool ConstTensor::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ConstTensor::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
void ConstTensor::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
void ConstTensor::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
::google::protobuf::int64 ConstTensor::offset() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.offset)
  return offset_;
}
void ConstTensor::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:mace.ConstTensor.offset)
}

// optional int64 data_size = 7;
bool ConstTensor::has_data_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ConstTensor::set_has_data_size() {
  _has_bits_[0] |= 0x00000004u;
}
void ConstTensor::clear_has_data_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void ConstTensor::clear_data_size() {
  data_size_ = GOOGLE_LONGLONG(0);
  clear_has_data_size();
}
::google::protobuf::int64 ConstTensor::data_size() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.data_size)
  return data_size_;
}
void ConstTensor::set_data_size(::google::protobuf::int64 value) {
  set_has_data_size();
  data_size_ = value;
  // @@protoc_insertion_point(field_set:mace.ConstTensor.data_size)
}

// optional uint32 node_id = 100;
bool ConstTensor::has_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ConstTensor::set_has_node_id() {
  _has_bits_[0] |= 0x00000008u;
}
void ConstTensor::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void ConstTensor::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
::google::protobuf::uint32 ConstTensor::node_id() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.node_id)
  return node_id_;
}
void ConstTensor::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.ConstTensor.node_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Argument::kNameFieldNumber;
const int Argument::kFFieldNumber;
const int Argument::kIFieldNumber;
const int Argument::kSFieldNumber;
const int Argument::kFloatsFieldNumber;
const int Argument::kIntsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Argument::Argument()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.Argument)
}
Argument::Argument(const Argument& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      floats_(from.floats_),
      ints_(from.ints_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_s()) {
    s_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.s_);
  }
  ::memcpy(&i_, &from.i_,
    static_cast<size_t>(reinterpret_cast<char*>(&f_) -
    reinterpret_cast<char*>(&i_)) + sizeof(f_));
  // @@protoc_insertion_point(copy_constructor:mace.Argument)
}

void Argument::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&i_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&f_) -
      reinterpret_cast<char*>(&i_)) + sizeof(f_));
}

Argument::~Argument() {
  // @@protoc_insertion_point(destructor:mace.Argument)
  SharedDtor();
}

void Argument::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  s_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Argument::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Argument& Argument::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

Argument* Argument::New(::google::protobuf::Arena* arena) const {
  Argument* n = new Argument;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Argument::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.Argument)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  floats_.Clear();
  ints_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!s_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*s_.UnsafeRawStringPointer())->clear();
    }
  }
  if (cached_has_bits & 12u) {
    ::memset(&i_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&f_) -
        reinterpret_cast<char*>(&i_)) + sizeof(f_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Argument::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.Argument)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float f = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(21u /* 21 & 0xFF */)) {
          set_has_f();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &f_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 i = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_i();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &i_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes s = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_s()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated float floats = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(45u /* 45 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 45u, input, this->mutable_floats())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_floats())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int64 ints = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 48u, input, this->mutable_ints())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_ints())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.Argument)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.Argument)
  return false;
#undef DO_
}

void Argument::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.Argument)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional float f = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->f(), output);
  }

  // optional int64 i = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->i(), output);
  }

  // optional bytes s = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->s(), output);
  }

  // repeated float floats = 5;
  for (int i = 0, n = this->floats_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      5, this->floats(i), output);
  }

  // repeated int64 ints = 6;
  for (int i = 0, n = this->ints_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      6, this->ints(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.Argument)
}

size_t Argument::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.Argument)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated float floats = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->floats_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->floats_size());
    total_size += data_size;
  }

  // repeated int64 ints = 6;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->ints_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->ints_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 15u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bytes s = 4;
    if (has_s()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->s());
    }

    // optional int64 i = 3;
    if (has_i()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->i());
    }

    // optional float f = 2;
    if (has_f()) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Argument::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Argument*>(&from));
}

void Argument::MergeFrom(const Argument& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.Argument)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  floats_.MergeFrom(from.floats_);
  ints_.MergeFrom(from.ints_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_s();
      s_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.s_);
    }
    if (cached_has_bits & 0x00000004u) {
      i_ = from.i_;
    }
    if (cached_has_bits & 0x00000008u) {
      f_ = from.f_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Argument::CopyFrom(const Argument& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.Argument)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Argument::IsInitialized() const {
  return true;
}

void Argument::Swap(Argument* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Argument::InternalSwap(Argument* other) {
  using std::swap;
  floats_.InternalSwap(&other->floats_);
  ints_.InternalSwap(&other->ints_);
  name_.Swap(&other->name_);
  s_.Swap(&other->s_);
  swap(i_, other->i_);
  swap(f_, other->f_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string Argument::GetTypeName() const {
  return "mace.Argument";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Argument

// optional string name = 1;
bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Argument::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Argument::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Argument::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:mace.Argument.name)
  return name_.GetNoArena();
}
void Argument::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.Argument.name)
}
#if LANG_CXX11
void Argument::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.Argument.name)
}
#endif
void Argument::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.Argument.name)
}
void Argument::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.Argument.name)
}
::std::string* Argument::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.Argument.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:mace.Argument.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Argument::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.Argument.name)
}

// optional float f = 2;
bool Argument::has_f() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Argument::set_has_f() {
  _has_bits_[0] |= 0x00000008u;
}
void Argument::clear_has_f() {
  _has_bits_[0] &= ~0x00000008u;
}
void Argument::clear_f() {
  f_ = 0;
  clear_has_f();
}
float Argument::f() const {
  // @@protoc_insertion_point(field_get:mace.Argument.f)
  return f_;
}
void Argument::set_f(float value) {
  set_has_f();
  f_ = value;
  // @@protoc_insertion_point(field_set:mace.Argument.f)
}

// optional int64 i = 3;
bool Argument::has_i() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Argument::set_has_i() {
  _has_bits_[0] |= 0x00000004u;
}
void Argument::clear_has_i() {
  _has_bits_[0] &= ~0x00000004u;
}
void Argument::clear_i() {
  i_ = GOOGLE_LONGLONG(0);
  clear_has_i();
}
::google::protobuf::int64 Argument::i() const {
  // @@protoc_insertion_point(field_get:mace.Argument.i)
  return i_;
}
void Argument::set_i(::google::protobuf::int64 value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:mace.Argument.i)
}

// optional bytes s = 4;
bool Argument::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Argument::set_has_s() {
  _has_bits_[0] |= 0x00000002u;
}
void Argument::clear_has_s() {
  _has_bits_[0] &= ~0x00000002u;
}
void Argument::clear_s() {
  s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s();
}
const ::std::string& Argument::s() const {
  // @@protoc_insertion_point(field_get:mace.Argument.s)
  return s_.GetNoArena();
}
void Argument::set_s(const ::std::string& value) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.Argument.s)
}
#if LANG_CXX11
void Argument::set_s(::std::string&& value) {
  set_has_s();
  s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.Argument.s)
}
#endif
void Argument::set_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.Argument.s)
}
void Argument::set_s(const void* value, size_t size) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.Argument.s)
}
::std::string* Argument::mutable_s() {
  set_has_s();
  // @@protoc_insertion_point(field_mutable:mace.Argument.s)
  return s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Argument::release_s() {
  // @@protoc_insertion_point(field_release:mace.Argument.s)
  clear_has_s();
  return s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Argument::set_allocated_s(::std::string* s) {
  if (s != NULL) {
    set_has_s();
  } else {
    clear_has_s();
  }
  s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:mace.Argument.s)
}

// repeated float floats = 5;
int Argument::floats_size() const {
  return floats_.size();
}
void Argument::clear_floats() {
  floats_.Clear();
}
float Argument::floats(int index) const {
  // @@protoc_insertion_point(field_get:mace.Argument.floats)
  return floats_.Get(index);
}
void Argument::set_floats(int index, float value) {
  floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.Argument.floats)
}
void Argument::add_floats(float value) {
  floats_.Add(value);
  // @@protoc_insertion_point(field_add:mace.Argument.floats)
}
const ::google::protobuf::RepeatedField< float >&
Argument::floats() const {
  // @@protoc_insertion_point(field_list:mace.Argument.floats)
  return floats_;
}
::google::protobuf::RepeatedField< float >*
Argument::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:mace.Argument.floats)
  return &floats_;
}

// repeated int64 ints = 6;
int Argument::ints_size() const {
  return ints_.size();
}
void Argument::clear_ints() {
  ints_.Clear();
}
::google::protobuf::int64 Argument::ints(int index) const {
  // @@protoc_insertion_point(field_get:mace.Argument.ints)
  return ints_.Get(index);
}
void Argument::set_ints(int index, ::google::protobuf::int64 value) {
  ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.Argument.ints)
}
void Argument::add_ints(::google::protobuf::int64 value) {
  ints_.Add(value);
  // @@protoc_insertion_point(field_add:mace.Argument.ints)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Argument::ints() const {
  // @@protoc_insertion_point(field_list:mace.Argument.ints)
  return ints_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Argument::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:mace.Argument.ints)
  return &ints_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NodeInput::kNodeIdFieldNumber;
const int NodeInput::kOutputPortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NodeInput::NodeInput()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.NodeInput)
}
NodeInput::NodeInput(const NodeInput& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&node_id_, &from.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&output_port_) -
    reinterpret_cast<char*>(&node_id_)) + sizeof(output_port_));
  // @@protoc_insertion_point(copy_constructor:mace.NodeInput)
}

void NodeInput::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&output_port_) -
      reinterpret_cast<char*>(&node_id_)) + sizeof(output_port_));
}

NodeInput::~NodeInput() {
  // @@protoc_insertion_point(destructor:mace.NodeInput)
  SharedDtor();
}

void NodeInput::SharedDtor() {
}

void NodeInput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NodeInput& NodeInput::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

NodeInput* NodeInput::New(::google::protobuf::Arena* arena) const {
  NodeInput* n = new NodeInput;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NodeInput::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.NodeInput)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&output_port_) -
        reinterpret_cast<char*>(&node_id_)) + sizeof(output_port_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool NodeInput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.NodeInput)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 node_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_node_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 output_port = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_output_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &output_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.NodeInput)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.NodeInput)
  return false;
#undef DO_
}

void NodeInput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.NodeInput)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 node_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->node_id(), output);
  }

  // optional int32 output_port = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->output_port(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.NodeInput)
}

size_t NodeInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.NodeInput)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional int32 node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional int32 output_port = 2;
    if (has_output_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->output_port());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NodeInput::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NodeInput*>(&from));
}

void NodeInput::MergeFrom(const NodeInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.NodeInput)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      node_id_ = from.node_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      output_port_ = from.output_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NodeInput::CopyFrom(const NodeInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.NodeInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeInput::IsInitialized() const {
  return true;
}

void NodeInput::Swap(NodeInput* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NodeInput::InternalSwap(NodeInput* other) {
  using std::swap;
  swap(node_id_, other->node_id_);
  swap(output_port_, other->output_port_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string NodeInput::GetTypeName() const {
  return "mace.NodeInput";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NodeInput

// optional int32 node_id = 1;
bool NodeInput::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NodeInput::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
void NodeInput::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void NodeInput::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
::google::protobuf::int32 NodeInput::node_id() const {
  // @@protoc_insertion_point(field_get:mace.NodeInput.node_id)
  return node_id_;
}
void NodeInput::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.NodeInput.node_id)
}

// optional int32 output_port = 2;
bool NodeInput::has_output_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NodeInput::set_has_output_port() {
  _has_bits_[0] |= 0x00000002u;
}
void NodeInput::clear_has_output_port() {
  _has_bits_[0] &= ~0x00000002u;
}
void NodeInput::clear_output_port() {
  output_port_ = 0;
  clear_has_output_port();
}
::google::protobuf::int32 NodeInput::output_port() const {
  // @@protoc_insertion_point(field_get:mace.NodeInput.output_port)
  return output_port_;
}
void NodeInput::set_output_port(::google::protobuf::int32 value) {
  set_has_output_port();
  output_port_ = value;
  // @@protoc_insertion_point(field_set:mace.NodeInput.output_port)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OutputShape::kDimsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OutputShape::OutputShape()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.OutputShape)
}
OutputShape::OutputShape(const OutputShape& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      dims_(from.dims_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mace.OutputShape)
}

void OutputShape::SharedCtor() {
  _cached_size_ = 0;
}

OutputShape::~OutputShape() {
  // @@protoc_insertion_point(destructor:mace.OutputShape)
  SharedDtor();
}

void OutputShape::SharedDtor() {
}

void OutputShape::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OutputShape& OutputShape::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

OutputShape* OutputShape::New(::google::protobuf::Arena* arena) const {
  OutputShape* n = new OutputShape;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OutputShape::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.OutputShape)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool OutputShape::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.OutputShape)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 dims = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 8u, input, this->mutable_dims())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_dims())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.OutputShape)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.OutputShape)
  return false;
#undef DO_
}

void OutputShape::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.OutputShape)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 dims = 1;
  for (int i = 0, n = this->dims_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      1, this->dims(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.OutputShape)
}

size_t OutputShape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.OutputShape)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated int64 dims = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int64Size(this->dims_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->dims_size());
    total_size += data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OutputShape::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OutputShape*>(&from));
}

void OutputShape::MergeFrom(const OutputShape& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.OutputShape)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
}

void OutputShape::CopyFrom(const OutputShape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.OutputShape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputShape::IsInitialized() const {
  return true;
}

void OutputShape::Swap(OutputShape* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OutputShape::InternalSwap(OutputShape* other) {
  using std::swap;
  dims_.InternalSwap(&other->dims_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string OutputShape::GetTypeName() const {
  return "mace.OutputShape";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OutputShape

// repeated int64 dims = 1;
int OutputShape::dims_size() const {
  return dims_.size();
}
void OutputShape::clear_dims() {
  dims_.Clear();
}
::google::protobuf::int64 OutputShape::dims(int index) const {
  // @@protoc_insertion_point(field_get:mace.OutputShape.dims)
  return dims_.Get(index);
}
void OutputShape::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OutputShape.dims)
}
void OutputShape::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OutputShape.dims)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
OutputShape::dims() const {
  // @@protoc_insertion_point(field_list:mace.OutputShape.dims)
  return dims_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
OutputShape::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:mace.OutputShape.dims)
  return &dims_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OperatorDef::kInputFieldNumber;
const int OperatorDef::kOutputFieldNumber;
const int OperatorDef::kNameFieldNumber;
const int OperatorDef::kTypeFieldNumber;
const int OperatorDef::kArgFieldNumber;
const int OperatorDef::kOutputShapeFieldNumber;
const int OperatorDef::kOutputTypeFieldNumber;
const int OperatorDef::kMemIdFieldNumber;
const int OperatorDef::kNodeIdFieldNumber;
const int OperatorDef::kOpIdFieldNumber;
const int OperatorDef::kPaddingFieldNumber;
const int OperatorDef::kNodeInputFieldNumber;
const int OperatorDef::kOutMaxByteSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OperatorDef::OperatorDef()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.OperatorDef)
}
OperatorDef::OperatorDef(const OperatorDef& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      input_(from.input_),
      output_(from.output_),
      arg_(from.arg_),
      output_shape_(from.output_shape_),
      output_type_(from.output_type_),
      mem_id_(from.mem_id_),
      node_input_(from.node_input_),
      out_max_byte_size_(from.out_max_byte_size_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_type()) {
    type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
  }
  ::memcpy(&padding_, &from.padding_,
    static_cast<size_t>(reinterpret_cast<char*>(&op_id_) -
    reinterpret_cast<char*>(&padding_)) + sizeof(op_id_));
  // @@protoc_insertion_point(copy_constructor:mace.OperatorDef)
}

void OperatorDef::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&padding_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&op_id_) -
      reinterpret_cast<char*>(&padding_)) + sizeof(op_id_));
}

OperatorDef::~OperatorDef() {
  // @@protoc_insertion_point(destructor:mace.OperatorDef)
  SharedDtor();
}

void OperatorDef::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void OperatorDef::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OperatorDef& OperatorDef::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

OperatorDef* OperatorDef::New(::google::protobuf::Arena* arena) const {
  OperatorDef* n = new OperatorDef;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OperatorDef::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.OperatorDef)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  input_.Clear();
  output_.Clear();
  arg_.Clear();
  output_shape_.Clear();
  output_type_.Clear();
  mem_id_.Clear();
  node_input_.Clear();
  out_max_byte_size_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!type_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*type_.UnsafeRawStringPointer())->clear();
    }
  }
  if (cached_has_bits & 28u) {
    ::memset(&padding_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&op_id_) -
        reinterpret_cast<char*>(&padding_)) + sizeof(op_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool OperatorDef::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.OperatorDef)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string input = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_input()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string output = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_output()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.Argument arg = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_arg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.OutputShape output_shape = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_output_shape()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.DataType output_type = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mace::DataType_IsValid(value)) {
            add_output_type(static_cast< ::mace::DataType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 7,
                 ::mace::DataType_IsValid,
                 &unknown_fields_stream,
                 this->mutable_output_type())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 mem_id = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 80u, input, this->mutable_mem_id())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_mem_id())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 node_id = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 800 & 0xFF */)) {
          set_has_node_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 op_id = 101;
      case 101: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 808 & 0xFF */)) {
          set_has_op_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &op_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 padding = 102;
      case 102: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 816 & 0xFF */)) {
          set_has_padding();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &padding_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.NodeInput node_input = 103;
      case 103: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 826 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_node_input()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 out_max_byte_size = 104;
      case 104: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 832 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 2, 832u, input, this->mutable_out_max_byte_size())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 834 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_out_max_byte_size())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.OperatorDef)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.OperatorDef)
  return false;
#undef DO_
}

void OperatorDef::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.OperatorDef)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string input = 1;
  for (int i = 0, n = this->input_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->input(i), output);
  }

  // repeated string output = 2;
  for (int i = 0, n = this->output_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->output(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional string type = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->type(), output);
  }

  // repeated .mace.Argument arg = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->arg_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->arg(static_cast<int>(i)), output);
  }

  // repeated .mace.OutputShape output_shape = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->output_shape_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->output_shape(static_cast<int>(i)), output);
  }

  // repeated .mace.DataType output_type = 7;
  for (int i = 0, n = this->output_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->output_type(i), output);
  }

  // repeated int32 mem_id = 10;
  for (int i = 0, n = this->mem_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      10, this->mem_id(i), output);
  }

  // optional uint32 node_id = 100;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(100, this->node_id(), output);
  }

  // optional uint32 op_id = 101;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(101, this->op_id(), output);
  }

  // optional uint32 padding = 102;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(102, this->padding(), output);
  }

  // repeated .mace.NodeInput node_input = 103;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->node_input_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      103, this->node_input(static_cast<int>(i)), output);
  }

  // repeated int32 out_max_byte_size = 104;
  for (int i = 0, n = this->out_max_byte_size_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      104, this->out_max_byte_size(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.OperatorDef)
}

size_t OperatorDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.OperatorDef)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated string input = 1;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->input_size());
  for (int i = 0, n = this->input_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->input(i));
  }

  // repeated string output = 2;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->output_size());
  for (int i = 0, n = this->output_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->output(i));
  }

  // repeated .mace.Argument arg = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->arg_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->arg(static_cast<int>(i)));
    }
  }

  // repeated .mace.OutputShape output_shape = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->output_shape_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->output_shape(static_cast<int>(i)));
    }
  }

  // repeated .mace.DataType output_type = 7;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->output_type_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->output_type(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated int32 mem_id = 10;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->mem_id_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->mem_id_size());
    total_size += data_size;
  }

  // repeated .mace.NodeInput node_input = 103;
  {
    unsigned int count = static_cast<unsigned int>(this->node_input_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->node_input(static_cast<int>(i)));
    }
  }

  // repeated int32 out_max_byte_size = 104;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->out_max_byte_size_);
    total_size += 2 *
                  ::google::protobuf::internal::FromIntSize(this->out_max_byte_size_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 31u) {
    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional uint32 padding = 102;
    if (has_padding()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->padding());
    }

    // optional uint32 node_id = 100;
    if (has_node_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_id());
    }

    // optional uint32 op_id = 101;
    if (has_op_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->op_id());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OperatorDef::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OperatorDef*>(&from));
}

void OperatorDef::MergeFrom(const OperatorDef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.OperatorDef)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  input_.MergeFrom(from.input_);
  output_.MergeFrom(from.output_);
  arg_.MergeFrom(from.arg_);
  output_shape_.MergeFrom(from.output_shape_);
  output_type_.MergeFrom(from.output_type_);
  mem_id_.MergeFrom(from.mem_id_);
  node_input_.MergeFrom(from.node_input_);
  out_max_byte_size_.MergeFrom(from.out_max_byte_size_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_type();
      type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
    }
    if (cached_has_bits & 0x00000004u) {
      padding_ = from.padding_;
    }
    if (cached_has_bits & 0x00000008u) {
      node_id_ = from.node_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      op_id_ = from.op_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void OperatorDef::CopyFrom(const OperatorDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.OperatorDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OperatorDef::IsInitialized() const {
  return true;
}

void OperatorDef::Swap(OperatorDef* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OperatorDef::InternalSwap(OperatorDef* other) {
  using std::swap;
  input_.InternalSwap(&other->input_);
  output_.InternalSwap(&other->output_);
  arg_.InternalSwap(&other->arg_);
  output_shape_.InternalSwap(&other->output_shape_);
  output_type_.InternalSwap(&other->output_type_);
  mem_id_.InternalSwap(&other->mem_id_);
  node_input_.InternalSwap(&other->node_input_);
  out_max_byte_size_.InternalSwap(&other->out_max_byte_size_);
  name_.Swap(&other->name_);
  type_.Swap(&other->type_);
  swap(padding_, other->padding_);
  swap(node_id_, other->node_id_);
  swap(op_id_, other->op_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string OperatorDef::GetTypeName() const {
  return "mace.OperatorDef";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OperatorDef

// repeated string input = 1;
int OperatorDef::input_size() const {
  return input_.size();
}
void OperatorDef::clear_input() {
  input_.Clear();
}
const ::std::string& OperatorDef::input(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.input)
  return input_.Get(index);
}
::std::string* OperatorDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.input)
  return input_.Mutable(index);
}
void OperatorDef::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mace.OperatorDef.input)
  input_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void OperatorDef::set_input(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mace.OperatorDef.input)
  input_.Mutable(index)->assign(std::move(value));
}
#endif
void OperatorDef::set_input(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mace.OperatorDef.input)
}
void OperatorDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mace.OperatorDef.input)
}
::std::string* OperatorDef::add_input() {
  // @@protoc_insertion_point(field_add_mutable:mace.OperatorDef.input)
  return input_.Add();
}
void OperatorDef::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.input)
}
#if LANG_CXX11
void OperatorDef::add_input(::std::string&& value) {
  input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mace.OperatorDef.input)
}
#endif
void OperatorDef::add_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mace.OperatorDef.input)
}
void OperatorDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mace.OperatorDef.input)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::input() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.input)
  return input_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.input)
  return &input_;
}

// repeated string output = 2;
int OperatorDef::output_size() const {
  return output_.size();
}
void OperatorDef::clear_output() {
  output_.Clear();
}
const ::std::string& OperatorDef::output(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.output)
  return output_.Get(index);
}
::std::string* OperatorDef::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.output)
  return output_.Mutable(index);
}
void OperatorDef::set_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mace.OperatorDef.output)
  output_.Mutable(index)->assign(value);
}
#if LANG_CXX11
void OperatorDef::set_output(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mace.OperatorDef.output)
  output_.Mutable(index)->assign(std::move(value));
}
#endif
void OperatorDef::set_output(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mace.OperatorDef.output)
}
void OperatorDef::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mace.OperatorDef.output)
}
::std::string* OperatorDef::add_output() {
  // @@protoc_insertion_point(field_add_mutable:mace.OperatorDef.output)
  return output_.Add();
}
void OperatorDef::add_output(const ::std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.output)
}
#if LANG_CXX11
void OperatorDef::add_output(::std::string&& value) {
  output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mace.OperatorDef.output)
}
#endif
void OperatorDef::add_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mace.OperatorDef.output)
}
void OperatorDef::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mace.OperatorDef.output)
}
const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::output() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.output)
  return output_;
}
::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.output)
  return &output_;
}

// optional string name = 3;
bool OperatorDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OperatorDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void OperatorDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void OperatorDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& OperatorDef::name() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.name)
  return name_.GetNoArena();
}
void OperatorDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.name)
}
#if LANG_CXX11
void OperatorDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.OperatorDef.name)
}
#endif
void OperatorDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.OperatorDef.name)
}
void OperatorDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.OperatorDef.name)
}
::std::string* OperatorDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* OperatorDef::release_name() {
  // @@protoc_insertion_point(field_release:mace.OperatorDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void OperatorDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.OperatorDef.name)
}

// optional string type = 4;
bool OperatorDef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void OperatorDef::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void OperatorDef::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void OperatorDef::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
const ::std::string& OperatorDef::type() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.type)
  return type_.GetNoArena();
}
void OperatorDef::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.type)
}
#if LANG_CXX11
void OperatorDef::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.OperatorDef.type)
}
#endif
void OperatorDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.OperatorDef.type)
}
void OperatorDef::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.OperatorDef.type)
}
::std::string* OperatorDef::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* OperatorDef::release_type() {
  // @@protoc_insertion_point(field_release:mace.OperatorDef.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void OperatorDef::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mace.OperatorDef.type)
}

// repeated .mace.Argument arg = 5;
int OperatorDef::arg_size() const {
  return arg_.size();
}
void OperatorDef::clear_arg() {
  arg_.Clear();
}
const ::mace::Argument& OperatorDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.arg)
  return arg_.Get(index);
}
::mace::Argument* OperatorDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.arg)
  return arg_.Mutable(index);
}
::mace::Argument* OperatorDef::add_arg() {
  // @@protoc_insertion_point(field_add:mace.OperatorDef.arg)
  return arg_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::Argument >*
OperatorDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.arg)
  return &arg_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::Argument >&
OperatorDef::arg() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.arg)
  return arg_;
}

// repeated .mace.OutputShape output_shape = 6;
int OperatorDef::output_shape_size() const {
  return output_shape_.size();
}
void OperatorDef::clear_output_shape() {
  output_shape_.Clear();
}
const ::mace::OutputShape& OperatorDef::output_shape(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.output_shape)
  return output_shape_.Get(index);
}
::mace::OutputShape* OperatorDef::mutable_output_shape(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.output_shape)
  return output_shape_.Mutable(index);
}
::mace::OutputShape* OperatorDef::add_output_shape() {
  // @@protoc_insertion_point(field_add:mace.OperatorDef.output_shape)
  return output_shape_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::OutputShape >*
OperatorDef::mutable_output_shape() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.output_shape)
  return &output_shape_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::OutputShape >&
OperatorDef::output_shape() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.output_shape)
  return output_shape_;
}

// repeated .mace.DataType output_type = 7;
int OperatorDef::output_type_size() const {
  return output_type_.size();
}
void OperatorDef::clear_output_type() {
  output_type_.Clear();
}
::mace::DataType OperatorDef::output_type(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.output_type)
  return static_cast< ::mace::DataType >(output_type_.Get(index));
}
void OperatorDef::set_output_type(int index, ::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  output_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.output_type)
}
void OperatorDef::add_output_type(::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  output_type_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.output_type)
}
const ::google::protobuf::RepeatedField<int>&
OperatorDef::output_type() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.output_type)
  return output_type_;
}
::google::protobuf::RepeatedField<int>*
OperatorDef::mutable_output_type() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.output_type)
  return &output_type_;
}

// repeated int32 mem_id = 10;
int OperatorDef::mem_id_size() const {
  return mem_id_.size();
}
void OperatorDef::clear_mem_id() {
  mem_id_.Clear();
}
::google::protobuf::int32 OperatorDef::mem_id(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.mem_id)
  return mem_id_.Get(index);
}
void OperatorDef::set_mem_id(int index, ::google::protobuf::int32 value) {
  mem_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.mem_id)
}
void OperatorDef::add_mem_id(::google::protobuf::int32 value) {
  mem_id_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.mem_id)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OperatorDef::mem_id() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.mem_id)
  return mem_id_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OperatorDef::mutable_mem_id() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.mem_id)
  return &mem_id_;
}

// optional uint32 node_id = 100;
bool OperatorDef::has_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void OperatorDef::set_has_node_id() {
  _has_bits_[0] |= 0x00000008u;
}
void OperatorDef::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void OperatorDef::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
::google::protobuf::uint32 OperatorDef::node_id() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.node_id)
  return node_id_;
}
void OperatorDef::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.OperatorDef.node_id)
}

// optional uint32 op_id = 101;
bool OperatorDef::has_op_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void OperatorDef::set_has_op_id() {
  _has_bits_[0] |= 0x00000010u;
}
void OperatorDef::clear_has_op_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void OperatorDef::clear_op_id() {
  op_id_ = 0u;
  clear_has_op_id();
}
::google::protobuf::uint32 OperatorDef::op_id() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.op_id)
  return op_id_;
}
void OperatorDef::set_op_id(::google::protobuf::uint32 value) {
  set_has_op_id();
  op_id_ = value;
  // @@protoc_insertion_point(field_set:mace.OperatorDef.op_id)
}

// optional uint32 padding = 102;
bool OperatorDef::has_padding() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void OperatorDef::set_has_padding() {
  _has_bits_[0] |= 0x00000004u;
}
void OperatorDef::clear_has_padding() {
  _has_bits_[0] &= ~0x00000004u;
}
void OperatorDef::clear_padding() {
  padding_ = 0u;
  clear_has_padding();
}
::google::protobuf::uint32 OperatorDef::padding() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.padding)
  return padding_;
}
void OperatorDef::set_padding(::google::protobuf::uint32 value) {
  set_has_padding();
  padding_ = value;
  // @@protoc_insertion_point(field_set:mace.OperatorDef.padding)
}

// repeated .mace.NodeInput node_input = 103;
int OperatorDef::node_input_size() const {
  return node_input_.size();
}
void OperatorDef::clear_node_input() {
  node_input_.Clear();
}
const ::mace::NodeInput& OperatorDef::node_input(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.node_input)
  return node_input_.Get(index);
}
::mace::NodeInput* OperatorDef::mutable_node_input(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.node_input)
  return node_input_.Mutable(index);
}
::mace::NodeInput* OperatorDef::add_node_input() {
  // @@protoc_insertion_point(field_add:mace.OperatorDef.node_input)
  return node_input_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::NodeInput >*
OperatorDef::mutable_node_input() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.node_input)
  return &node_input_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::NodeInput >&
OperatorDef::node_input() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.node_input)
  return node_input_;
}

// repeated int32 out_max_byte_size = 104;
int OperatorDef::out_max_byte_size_size() const {
  return out_max_byte_size_.size();
}
void OperatorDef::clear_out_max_byte_size() {
  out_max_byte_size_.Clear();
}
::google::protobuf::int32 OperatorDef::out_max_byte_size(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.out_max_byte_size)
  return out_max_byte_size_.Get(index);
}
void OperatorDef::set_out_max_byte_size(int index, ::google::protobuf::int32 value) {
  out_max_byte_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.out_max_byte_size)
}
void OperatorDef::add_out_max_byte_size(::google::protobuf::int32 value) {
  out_max_byte_size_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.out_max_byte_size)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OperatorDef::out_max_byte_size() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.out_max_byte_size)
  return out_max_byte_size_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OperatorDef::mutable_out_max_byte_size() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.out_max_byte_size)
  return &out_max_byte_size_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MemoryBlock::kMemIdFieldNumber;
const int MemoryBlock::kXFieldNumber;
const int MemoryBlock::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MemoryBlock::MemoryBlock()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.MemoryBlock)
}
MemoryBlock::MemoryBlock(const MemoryBlock& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&mem_id_, &from.mem_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&mem_id_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:mace.MemoryBlock)
}

void MemoryBlock::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&mem_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&mem_id_)) + sizeof(y_));
}

MemoryBlock::~MemoryBlock() {
  // @@protoc_insertion_point(destructor:mace.MemoryBlock)
  SharedDtor();
}

void MemoryBlock::SharedDtor() {
}

void MemoryBlock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MemoryBlock& MemoryBlock::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

MemoryBlock* MemoryBlock::New(::google::protobuf::Arena* arena) const {
  MemoryBlock* n = new MemoryBlock;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MemoryBlock::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.MemoryBlock)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&mem_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&mem_id_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool MemoryBlock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.MemoryBlock)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mem_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_mem_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mem_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 x = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_x();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 y = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_y();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.MemoryBlock)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.MemoryBlock)
  return false;
#undef DO_
}

void MemoryBlock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.MemoryBlock)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 mem_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mem_id(), output);
  }

  // optional uint32 x = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->x(), output);
  }

  // optional uint32 y = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->y(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.MemoryBlock)
}

size_t MemoryBlock::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.MemoryBlock)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (_has_bits_[0 / 32] & 7u) {
    // optional int32 mem_id = 1;
    if (has_mem_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mem_id());
    }

    // optional uint32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // optional uint32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemoryBlock::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MemoryBlock*>(&from));
}

void MemoryBlock::MergeFrom(const MemoryBlock& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.MemoryBlock)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mem_id_ = from.mem_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MemoryBlock::CopyFrom(const MemoryBlock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.MemoryBlock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemoryBlock::IsInitialized() const {
  return true;
}

void MemoryBlock::Swap(MemoryBlock* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MemoryBlock::InternalSwap(MemoryBlock* other) {
  using std::swap;
  swap(mem_id_, other->mem_id_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string MemoryBlock::GetTypeName() const {
  return "mace.MemoryBlock";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MemoryBlock

// optional int32 mem_id = 1;
bool MemoryBlock::has_mem_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MemoryBlock::set_has_mem_id() {
  _has_bits_[0] |= 0x00000001u;
}
void MemoryBlock::clear_has_mem_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void MemoryBlock::clear_mem_id() {
  mem_id_ = 0;
  clear_has_mem_id();
}
::google::protobuf::int32 MemoryBlock::mem_id() const {
  // @@protoc_insertion_point(field_get:mace.MemoryBlock.mem_id)
  return mem_id_;
}
void MemoryBlock::set_mem_id(::google::protobuf::int32 value) {
  set_has_mem_id();
  mem_id_ = value;
  // @@protoc_insertion_point(field_set:mace.MemoryBlock.mem_id)
}

// optional uint32 x = 2;
bool MemoryBlock::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MemoryBlock::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
void MemoryBlock::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
void MemoryBlock::clear_x() {
  x_ = 0u;
  clear_has_x();
}
::google::protobuf::uint32 MemoryBlock::x() const {
  // @@protoc_insertion_point(field_get:mace.MemoryBlock.x)
  return x_;
}
void MemoryBlock::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mace.MemoryBlock.x)
}

// optional uint32 y = 3;
bool MemoryBlock::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MemoryBlock::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
void MemoryBlock::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
void MemoryBlock::clear_y() {
  y_ = 0u;
  clear_has_y();
}
::google::protobuf::uint32 MemoryBlock::y() const {
  // @@protoc_insertion_point(field_get:mace.MemoryBlock.y)
  return y_;
}
void MemoryBlock::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mace.MemoryBlock.y)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MemoryArena::kMemBlockFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MemoryArena::MemoryArena()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.MemoryArena)
}
MemoryArena::MemoryArena(const MemoryArena& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      mem_block_(from.mem_block_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:mace.MemoryArena)
}

void MemoryArena::SharedCtor() {
  _cached_size_ = 0;
}

MemoryArena::~MemoryArena() {
  // @@protoc_insertion_point(destructor:mace.MemoryArena)
  SharedDtor();
}

void MemoryArena::SharedDtor() {
}

void MemoryArena::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MemoryArena& MemoryArena::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

MemoryArena* MemoryArena::New(::google::protobuf::Arena* arena) const {
  MemoryArena* n = new MemoryArena;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MemoryArena::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.MemoryArena)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mem_block_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool MemoryArena::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.MemoryArena)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mace.MemoryBlock mem_block = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mem_block()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.MemoryArena)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.MemoryArena)
  return false;
#undef DO_
}

void MemoryArena::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.MemoryArena)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .mace.MemoryBlock mem_block = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->mem_block_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->mem_block(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.MemoryArena)
}

size_t MemoryArena::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.MemoryArena)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mace.MemoryBlock mem_block = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->mem_block_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mem_block(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemoryArena::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MemoryArena*>(&from));
}

void MemoryArena::MergeFrom(const MemoryArena& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.MemoryArena)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  mem_block_.MergeFrom(from.mem_block_);
}

void MemoryArena::CopyFrom(const MemoryArena& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.MemoryArena)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemoryArena::IsInitialized() const {
  return true;
}

void MemoryArena::Swap(MemoryArena* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MemoryArena::InternalSwap(MemoryArena* other) {
  using std::swap;
  mem_block_.InternalSwap(&other->mem_block_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string MemoryArena::GetTypeName() const {
  return "mace.MemoryArena";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MemoryArena

// repeated .mace.MemoryBlock mem_block = 1;
int MemoryArena::mem_block_size() const {
  return mem_block_.size();
}
void MemoryArena::clear_mem_block() {
  mem_block_.Clear();
}
const ::mace::MemoryBlock& MemoryArena::mem_block(int index) const {
  // @@protoc_insertion_point(field_get:mace.MemoryArena.mem_block)
  return mem_block_.Get(index);
}
::mace::MemoryBlock* MemoryArena::mutable_mem_block(int index) {
  // @@protoc_insertion_point(field_mutable:mace.MemoryArena.mem_block)
  return mem_block_.Mutable(index);
}
::mace::MemoryBlock* MemoryArena::add_mem_block() {
  // @@protoc_insertion_point(field_add:mace.MemoryArena.mem_block)
  return mem_block_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::MemoryBlock >*
MemoryArena::mutable_mem_block() {
  // @@protoc_insertion_point(field_mutable_list:mace.MemoryArena.mem_block)
  return &mem_block_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::MemoryBlock >&
MemoryArena::mem_block() const {
  // @@protoc_insertion_point(field_list:mace.MemoryArena.mem_block)
  return mem_block_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InputInfo::kNameFieldNumber;
const int InputInfo::kNodeIdFieldNumber;
const int InputInfo::kDimsFieldNumber;
const int InputInfo::kMaxByteSizeFieldNumber;
const int InputInfo::kDataTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InputInfo::InputInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.InputInfo)
}
InputInfo::InputInfo(const InputInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      dims_(from.dims_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&node_id_, &from.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&node_id_)) + sizeof(data_type_));
  // @@protoc_insertion_point(copy_constructor:mace.InputInfo)
}

void InputInfo::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_byte_size_) -
      reinterpret_cast<char*>(&node_id_)) + sizeof(max_byte_size_));
  data_type_ = 1;
}

InputInfo::~InputInfo() {
  // @@protoc_insertion_point(destructor:mace.InputInfo)
  SharedDtor();
}

void InputInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void InputInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InputInfo& InputInfo::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

InputInfo* InputInfo::New(::google::protobuf::Arena* arena) const {
  InputInfo* n = new InputInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InputInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.InputInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  if (has_name()) {
    GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*name_.UnsafeRawStringPointer())->clear();
  }
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 14u) {
    ::memset(&node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_byte_size_) -
        reinterpret_cast<char*>(&node_id_)) + sizeof(max_byte_size_));
    data_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool InputInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.InputInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 node_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_node_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 dims = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24u, input, this->mutable_dims())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_dims())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_byte_size = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_max_byte_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_byte_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mace.DataType data_type = 5 [default = DT_FLOAT];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mace::DataType_IsValid(value)) {
            set_data_type(static_cast< ::mace::DataType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.InputInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.InputInfo)
  return false;
#undef DO_
}

void InputInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.InputInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional int32 node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->node_id(), output);
  }

  // repeated int32 dims = 3;
  for (int i = 0, n = this->dims_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->dims(i), output);
  }

  // optional int32 max_byte_size = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->max_byte_size(), output);
  }

  // optional .mace.DataType data_type = 5 [default = DT_FLOAT];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->data_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.InputInfo)
}

size_t InputInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.InputInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated int32 dims = 3;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->dims_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->dims_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 15u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 node_id = 2;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional int32 max_byte_size = 4;
    if (has_max_byte_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_byte_size());
    }

    // optional .mace.DataType data_type = 5 [default = DT_FLOAT];
    if (has_data_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InputInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InputInfo*>(&from));
}

void InputInfo::MergeFrom(const InputInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.InputInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      node_id_ = from.node_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_byte_size_ = from.max_byte_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      data_type_ = from.data_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InputInfo::CopyFrom(const InputInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.InputInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputInfo::IsInitialized() const {
  return true;
}

void InputInfo::Swap(InputInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InputInfo::InternalSwap(InputInfo* other) {
  using std::swap;
  dims_.InternalSwap(&other->dims_);
  name_.Swap(&other->name_);
  swap(node_id_, other->node_id_);
  swap(max_byte_size_, other->max_byte_size_);
  swap(data_type_, other->data_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string InputInfo::GetTypeName() const {
  return "mace.InputInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InputInfo

// optional string name = 1;
bool InputInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InputInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void InputInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void InputInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& InputInfo::name() const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.name)
  return name_.GetNoArena();
}
void InputInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.InputInfo.name)
}
#if LANG_CXX11
void InputInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.InputInfo.name)
}
#endif
void InputInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.InputInfo.name)
}
void InputInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.InputInfo.name)
}
::std::string* InputInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.InputInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* InputInfo::release_name() {
  // @@protoc_insertion_point(field_release:mace.InputInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void InputInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.InputInfo.name)
}

// optional int32 node_id = 2;
bool InputInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InputInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
void InputInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void InputInfo::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
::google::protobuf::int32 InputInfo::node_id() const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.node_id)
  return node_id_;
}
void InputInfo::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.InputInfo.node_id)
}

// repeated int32 dims = 3;
int InputInfo::dims_size() const {
  return dims_.size();
}
void InputInfo::clear_dims() {
  dims_.Clear();
}
::google::protobuf::int32 InputInfo::dims(int index) const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.dims)
  return dims_.Get(index);
}
void InputInfo::set_dims(int index, ::google::protobuf::int32 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.InputInfo.dims)
}
void InputInfo::add_dims(::google::protobuf::int32 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:mace.InputInfo.dims)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InputInfo::dims() const {
  // @@protoc_insertion_point(field_list:mace.InputInfo.dims)
  return dims_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InputInfo::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:mace.InputInfo.dims)
  return &dims_;
}

// optional int32 max_byte_size = 4;
bool InputInfo::has_max_byte_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void InputInfo::set_has_max_byte_size() {
  _has_bits_[0] |= 0x00000004u;
}
void InputInfo::clear_has_max_byte_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void InputInfo::clear_max_byte_size() {
  max_byte_size_ = 0;
  clear_has_max_byte_size();
}
::google::protobuf::int32 InputInfo::max_byte_size() const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.max_byte_size)
  return max_byte_size_;
}
void InputInfo::set_max_byte_size(::google::protobuf::int32 value) {
  set_has_max_byte_size();
  max_byte_size_ = value;
  // @@protoc_insertion_point(field_set:mace.InputInfo.max_byte_size)
}

// optional .mace.DataType data_type = 5 [default = DT_FLOAT];
bool InputInfo::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void InputInfo::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
void InputInfo::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void InputInfo::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
::mace::DataType InputInfo::data_type() const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.data_type)
  return static_cast< ::mace::DataType >(data_type_);
}
void InputInfo::set_data_type(::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:mace.InputInfo.data_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OutputInfo::kNameFieldNumber;
const int OutputInfo::kNodeIdFieldNumber;
const int OutputInfo::kDimsFieldNumber;
const int OutputInfo::kMaxByteSizeFieldNumber;
const int OutputInfo::kDataTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OutputInfo::OutputInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.OutputInfo)
}
OutputInfo::OutputInfo(const OutputInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      dims_(from.dims_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&node_id_, &from.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&node_id_)) + sizeof(data_type_));
  // @@protoc_insertion_point(copy_constructor:mace.OutputInfo)
}

void OutputInfo::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_byte_size_) -
      reinterpret_cast<char*>(&node_id_)) + sizeof(max_byte_size_));
  data_type_ = 1;
}

OutputInfo::~OutputInfo() {
  // @@protoc_insertion_point(destructor:mace.OutputInfo)
  SharedDtor();
}

void OutputInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void OutputInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OutputInfo& OutputInfo::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

OutputInfo* OutputInfo::New(::google::protobuf::Arena* arena) const {
  OutputInfo* n = new OutputInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OutputInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.OutputInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dims_.Clear();
  if (has_name()) {
    GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*name_.UnsafeRawStringPointer())->clear();
  }
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 14u) {
    ::memset(&node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_byte_size_) -
        reinterpret_cast<char*>(&node_id_)) + sizeof(max_byte_size_));
    data_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool OutputInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.OutputInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 node_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_node_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &node_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated int32 dims = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24u, input, this->mutable_dims())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_dims())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_byte_size = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_max_byte_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_byte_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mace.DataType data_type = 5 [default = DT_FLOAT];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mace::DataType_IsValid(value)) {
            set_data_type(static_cast< ::mace::DataType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.OutputInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.OutputInfo)
  return false;
#undef DO_
}

void OutputInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.OutputInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional int32 node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->node_id(), output);
  }

  // repeated int32 dims = 3;
  for (int i = 0, n = this->dims_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->dims(i), output);
  }

  // optional int32 max_byte_size = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->max_byte_size(), output);
  }

  // optional .mace.DataType data_type = 5 [default = DT_FLOAT];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->data_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.OutputInfo)
}

size_t OutputInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.OutputInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated int32 dims = 3;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      Int32Size(this->dims_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->dims_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 15u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 node_id = 2;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->node_id());
    }

    // optional int32 max_byte_size = 4;
    if (has_max_byte_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_byte_size());
    }

    // optional .mace.DataType data_type = 5 [default = DT_FLOAT];
    if (has_data_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OutputInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OutputInfo*>(&from));
}

void OutputInfo::MergeFrom(const OutputInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.OutputInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  dims_.MergeFrom(from.dims_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      node_id_ = from.node_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_byte_size_ = from.max_byte_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      data_type_ = from.data_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void OutputInfo::CopyFrom(const OutputInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.OutputInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputInfo::IsInitialized() const {
  return true;
}

void OutputInfo::Swap(OutputInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OutputInfo::InternalSwap(OutputInfo* other) {
  using std::swap;
  dims_.InternalSwap(&other->dims_);
  name_.Swap(&other->name_);
  swap(node_id_, other->node_id_);
  swap(max_byte_size_, other->max_byte_size_);
  swap(data_type_, other->data_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string OutputInfo::GetTypeName() const {
  return "mace.OutputInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OutputInfo

// optional string name = 1;
bool OutputInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OutputInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void OutputInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void OutputInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& OutputInfo::name() const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.name)
  return name_.GetNoArena();
}
void OutputInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.OutputInfo.name)
}
#if LANG_CXX11
void OutputInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.OutputInfo.name)
}
#endif
void OutputInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.OutputInfo.name)
}
void OutputInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.OutputInfo.name)
}
::std::string* OutputInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.OutputInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* OutputInfo::release_name() {
  // @@protoc_insertion_point(field_release:mace.OutputInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void OutputInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.OutputInfo.name)
}

// optional int32 node_id = 2;
bool OutputInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void OutputInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
void OutputInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void OutputInfo::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
::google::protobuf::int32 OutputInfo::node_id() const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.node_id)
  return node_id_;
}
void OutputInfo::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.OutputInfo.node_id)
}

// repeated int32 dims = 3;
int OutputInfo::dims_size() const {
  return dims_.size();
}
void OutputInfo::clear_dims() {
  dims_.Clear();
}
::google::protobuf::int32 OutputInfo::dims(int index) const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.dims)
  return dims_.Get(index);
}
void OutputInfo::set_dims(int index, ::google::protobuf::int32 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OutputInfo.dims)
}
void OutputInfo::add_dims(::google::protobuf::int32 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OutputInfo.dims)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OutputInfo::dims() const {
  // @@protoc_insertion_point(field_list:mace.OutputInfo.dims)
  return dims_;
}
::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OutputInfo::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:mace.OutputInfo.dims)
  return &dims_;
}

// optional int32 max_byte_size = 4;
bool OutputInfo::has_max_byte_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void OutputInfo::set_has_max_byte_size() {
  _has_bits_[0] |= 0x00000004u;
}
void OutputInfo::clear_has_max_byte_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void OutputInfo::clear_max_byte_size() {
  max_byte_size_ = 0;
  clear_has_max_byte_size();
}
::google::protobuf::int32 OutputInfo::max_byte_size() const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.max_byte_size)
  return max_byte_size_;
}
void OutputInfo::set_max_byte_size(::google::protobuf::int32 value) {
  set_has_max_byte_size();
  max_byte_size_ = value;
  // @@protoc_insertion_point(field_set:mace.OutputInfo.max_byte_size)
}

// optional .mace.DataType data_type = 5 [default = DT_FLOAT];
bool OutputInfo::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void OutputInfo::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
void OutputInfo::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void OutputInfo::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
::mace::DataType OutputInfo::data_type() const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.data_type)
  return static_cast< ::mace::DataType >(data_type_);
}
void OutputInfo::set_data_type(::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:mace.OutputInfo.data_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NetDef::kNameFieldNumber;
const int NetDef::kOpFieldNumber;
const int NetDef::kVersionFieldNumber;
const int NetDef::kArgFieldNumber;
const int NetDef::kTensorsFieldNumber;
const int NetDef::kMemArenaFieldNumber;
const int NetDef::kInputInfoFieldNumber;
const int NetDef::kOutputInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NetDef::NetDef()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_mace_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:mace.NetDef)
}
NetDef::NetDef(const NetDef& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      op_(from.op_),
      arg_(from.arg_),
      tensors_(from.tensors_),
      input_info_(from.input_info_),
      output_info_(from.output_info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  if (from.has_mem_arena()) {
    mem_arena_ = new ::mace::MemoryArena(*from.mem_arena_);
  } else {
    mem_arena_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:mace.NetDef)
}

void NetDef::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mem_arena_ = NULL;
}

NetDef::~NetDef() {
  // @@protoc_insertion_point(destructor:mace.NetDef)
  SharedDtor();
}

void NetDef::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete mem_arena_;
}

void NetDef::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NetDef& NetDef::default_instance() {
  protobuf_mace_2eproto::InitDefaults();
  return *internal_default_instance();
}

NetDef* NetDef::New(::google::protobuf::Arena* arena) const {
  NetDef* n = new NetDef;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NetDef::Clear() {
// @@protoc_insertion_point(message_clear_start:mace.NetDef)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  op_.Clear();
  arg_.Clear();
  tensors_.Clear();
  input_info_.Clear();
  output_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*name_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(!version_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*version_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(mem_arena_ != NULL);
      mem_arena_->::mace::MemoryArena::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool NetDef::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:mace.NetDef)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.OperatorDef op = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_op()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.Argument arg = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_arg()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.ConstTensor tensors = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tensors()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .mace.MemoryArena mem_arena = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mem_arena()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.InputInfo input_info = 100;
      case 100: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 802 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_input_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .mace.OutputInfo output_info = 101;
      case 101: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 810 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_output_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mace.NetDef)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mace.NetDef)
  return false;
#undef DO_
}

void NetDef::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mace.NetDef)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // repeated .mace.OperatorDef op = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->op_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->op(static_cast<int>(i)), output);
  }

  // optional string version = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->version(), output);
  }

  // repeated .mace.Argument arg = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->arg_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->arg(static_cast<int>(i)), output);
  }

  // repeated .mace.ConstTensor tensors = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->tensors_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->tensors(static_cast<int>(i)), output);
  }

  // optional .mace.MemoryArena mem_arena = 10;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, *this->mem_arena_, output);
  }

  // repeated .mace.InputInfo input_info = 100;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->input_info_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      100, this->input_info(static_cast<int>(i)), output);
  }

  // repeated .mace.OutputInfo output_info = 101;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->output_info_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      101, this->output_info(static_cast<int>(i)), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:mace.NetDef)
}

size_t NetDef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mace.NetDef)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .mace.OperatorDef op = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->op_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->op(static_cast<int>(i)));
    }
  }

  // repeated .mace.Argument arg = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->arg_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->arg(static_cast<int>(i)));
    }
  }

  // repeated .mace.ConstTensor tensors = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->tensors_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tensors(static_cast<int>(i)));
    }
  }

  // repeated .mace.InputInfo input_info = 100;
  {
    unsigned int count = static_cast<unsigned int>(this->input_info_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input_info(static_cast<int>(i)));
    }
  }

  // repeated .mace.OutputInfo output_info = 101;
  {
    unsigned int count = static_cast<unsigned int>(this->output_info_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->output_info(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 7u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .mace.MemoryArena mem_arena = 10;
    if (has_mem_arena()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mem_arena_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetDef::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NetDef*>(&from));
}

void NetDef::MergeFrom(const NetDef& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mace.NetDef)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  op_.MergeFrom(from.op_);
  arg_.MergeFrom(from.arg_);
  tensors_.MergeFrom(from.tensors_);
  input_info_.MergeFrom(from.input_info_);
  output_info_.MergeFrom(from.output_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_version();
      version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_mem_arena()->::mace::MemoryArena::MergeFrom(from.mem_arena());
    }
  }
}

void NetDef::CopyFrom(const NetDef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mace.NetDef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetDef::IsInitialized() const {
  return true;
}

void NetDef::Swap(NetDef* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NetDef::InternalSwap(NetDef* other) {
  using std::swap;
  op_.InternalSwap(&other->op_);
  arg_.InternalSwap(&other->arg_);
  tensors_.InternalSwap(&other->tensors_);
  input_info_.InternalSwap(&other->input_info_);
  output_info_.InternalSwap(&other->output_info_);
  name_.Swap(&other->name_);
  version_.Swap(&other->version_);
  swap(mem_arena_, other->mem_arena_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::std::string NetDef::GetTypeName() const {
  return "mace.NetDef";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NetDef

// optional string name = 1;
bool NetDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NetDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void NetDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void NetDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& NetDef::name() const {
  // @@protoc_insertion_point(field_get:mace.NetDef.name)
  return name_.GetNoArena();
}
void NetDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.NetDef.name)
}
#if LANG_CXX11
void NetDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.NetDef.name)
}
#endif
void NetDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.NetDef.name)
}
void NetDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.NetDef.name)
}
::std::string* NetDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.NetDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NetDef::release_name() {
  // @@protoc_insertion_point(field_release:mace.NetDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NetDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.NetDef.name)
}

// repeated .mace.OperatorDef op = 2;
int NetDef::op_size() const {
  return op_.size();
}
void NetDef::clear_op() {
  op_.Clear();
}
const ::mace::OperatorDef& NetDef::op(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.op)
  return op_.Get(index);
}
::mace::OperatorDef* NetDef::mutable_op(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.op)
  return op_.Mutable(index);
}
::mace::OperatorDef* NetDef::add_op() {
  // @@protoc_insertion_point(field_add:mace.NetDef.op)
  return op_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::OperatorDef >*
NetDef::mutable_op() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.op)
  return &op_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::OperatorDef >&
NetDef::op() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.op)
  return op_;
}

// optional string version = 3;
bool NetDef::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NetDef::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
void NetDef::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void NetDef::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
const ::std::string& NetDef::version() const {
  // @@protoc_insertion_point(field_get:mace.NetDef.version)
  return version_.GetNoArena();
}
void NetDef::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.NetDef.version)
}
#if LANG_CXX11
void NetDef::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.NetDef.version)
}
#endif
void NetDef::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.NetDef.version)
}
void NetDef::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.NetDef.version)
}
::std::string* NetDef::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mace.NetDef.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NetDef::release_version() {
  // @@protoc_insertion_point(field_release:mace.NetDef.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NetDef::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:mace.NetDef.version)
}

// repeated .mace.Argument arg = 4;
int NetDef::arg_size() const {
  return arg_.size();
}
void NetDef::clear_arg() {
  arg_.Clear();
}
const ::mace::Argument& NetDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.arg)
  return arg_.Get(index);
}
::mace::Argument* NetDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.arg)
  return arg_.Mutable(index);
}
::mace::Argument* NetDef::add_arg() {
  // @@protoc_insertion_point(field_add:mace.NetDef.arg)
  return arg_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::Argument >*
NetDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.arg)
  return &arg_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::Argument >&
NetDef::arg() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.arg)
  return arg_;
}

// repeated .mace.ConstTensor tensors = 5;
int NetDef::tensors_size() const {
  return tensors_.size();
}
void NetDef::clear_tensors() {
  tensors_.Clear();
}
const ::mace::ConstTensor& NetDef::tensors(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.tensors)
  return tensors_.Get(index);
}
::mace::ConstTensor* NetDef::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.tensors)
  return tensors_.Mutable(index);
}
::mace::ConstTensor* NetDef::add_tensors() {
  // @@protoc_insertion_point(field_add:mace.NetDef.tensors)
  return tensors_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >*
NetDef::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.tensors)
  return &tensors_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >&
NetDef::tensors() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.tensors)
  return tensors_;
}

// optional .mace.MemoryArena mem_arena = 10;
bool NetDef::has_mem_arena() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void NetDef::set_has_mem_arena() {
  _has_bits_[0] |= 0x00000004u;
}
void NetDef::clear_has_mem_arena() {
  _has_bits_[0] &= ~0x00000004u;
}
void NetDef::clear_mem_arena() {
  if (mem_arena_ != NULL) mem_arena_->::mace::MemoryArena::Clear();
  clear_has_mem_arena();
}
const ::mace::MemoryArena& NetDef::mem_arena() const {
  const ::mace::MemoryArena* p = mem_arena_;
  // @@protoc_insertion_point(field_get:mace.NetDef.mem_arena)
  return p != NULL ? *p : *reinterpret_cast<const ::mace::MemoryArena*>(
      &::mace::_MemoryArena_default_instance_);
}
::mace::MemoryArena* NetDef::mutable_mem_arena() {
  set_has_mem_arena();
  if (mem_arena_ == NULL) {
    mem_arena_ = new ::mace::MemoryArena;
  }
  // @@protoc_insertion_point(field_mutable:mace.NetDef.mem_arena)
  return mem_arena_;
}
::mace::MemoryArena* NetDef::release_mem_arena() {
  // @@protoc_insertion_point(field_release:mace.NetDef.mem_arena)
  clear_has_mem_arena();
  ::mace::MemoryArena* temp = mem_arena_;
  mem_arena_ = NULL;
  return temp;
}
void NetDef::set_allocated_mem_arena(::mace::MemoryArena* mem_arena) {
  delete mem_arena_;
  mem_arena_ = mem_arena;
  if (mem_arena) {
    set_has_mem_arena();
  } else {
    clear_has_mem_arena();
  }
  // @@protoc_insertion_point(field_set_allocated:mace.NetDef.mem_arena)
}

// repeated .mace.InputInfo input_info = 100;
int NetDef::input_info_size() const {
  return input_info_.size();
}
void NetDef::clear_input_info() {
  input_info_.Clear();
}
const ::mace::InputInfo& NetDef::input_info(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.input_info)
  return input_info_.Get(index);
}
::mace::InputInfo* NetDef::mutable_input_info(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.input_info)
  return input_info_.Mutable(index);
}
::mace::InputInfo* NetDef::add_input_info() {
  // @@protoc_insertion_point(field_add:mace.NetDef.input_info)
  return input_info_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::InputInfo >*
NetDef::mutable_input_info() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.input_info)
  return &input_info_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::InputInfo >&
NetDef::input_info() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.input_info)
  return input_info_;
}

// repeated .mace.OutputInfo output_info = 101;
int NetDef::output_info_size() const {
  return output_info_.size();
}
void NetDef::clear_output_info() {
  output_info_.Clear();
}
const ::mace::OutputInfo& NetDef::output_info(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.output_info)
  return output_info_.Get(index);
}
::mace::OutputInfo* NetDef::mutable_output_info(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.output_info)
  return output_info_.Mutable(index);
}
::mace::OutputInfo* NetDef::add_output_info() {
  // @@protoc_insertion_point(field_add:mace.NetDef.output_info)
  return output_info_.Add();
}
::google::protobuf::RepeatedPtrField< ::mace::OutputInfo >*
NetDef::mutable_output_info() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.output_info)
  return &output_info_;
}
const ::google::protobuf::RepeatedPtrField< ::mace::OutputInfo >&
NetDef::output_info() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.output_info)
  return output_info_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace mace

// @@protoc_insertion_point(global_scope)
